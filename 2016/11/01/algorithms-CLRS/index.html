<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CLRS 笔记 | nyakokishi's timeline</title><link rel="stylesheet" type="text/css" href="/timeline//css/normalize.css"><link rel="stylesheet" type="text/css" href="/timeline//css/highlight.css"><link rel="stylesheet" type="text/css" href="/timeline//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/timeline/favicon.ico"></head><body><header><div class="container header"><a class="title" id="logo" href="/timeline/.">nyakokishi's timeline</a><span class="subtitle">(༎ຶ‿༎ຶ)</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><input id="menu" type="checkbox"><nav id="nav"><div class="container"><a class="sidebar-nav-item" href="/timeline/">Home</a><a class="sidebar-nav-item" href="/timeline/archives">Archives</a></div></nav><div id="header-margin-bar"></div><div class="wrapper"><div class="container post-header"><h1>CLRS 笔记</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-11-01 12:00</div><div class="post-tags"><a class="post-tag-link" href="/timeline/tags/Algorithms/">Algorithms</a></div></div></div><article><div class="container post"><p>CLRS 笔记<br><a id="more"></a></p>
<h2 id="Θ记号"><a href="#Θ记号" class="headerlink" title="Θ记号"></a>Θ记号</h2><p>Θ记号渐进的给出了一个函数的上界和下界</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Θ(g(n)) = &#123;f(n):存在正常量c1,c2,和n0，使得对所有n ≥ n0， 有0 ≤ c1g(n) ≤ f(n) ≤ c2g(n)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="O记号"><a href="#O记号" class="headerlink" title="O记号"></a>O记号</h2><p>表示一个函数的渐进上界</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(g(n)) = &#123;f(n):存在正常量c,和n0，使得对所有n ≥ n0， 有0 ≤ f(n) ≤ cg(n)&#125;</span><br></pre></td></tr></table></figure>
<p>用来描述一个算法在最坏情况下的运行时间</p>
<h2 id="Ω记号"><a href="#Ω记号" class="headerlink" title="Ω记号"></a>Ω记号</h2><p>表示一个函数的渐进下界</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ω(g(n)) = &#123;f(n):存在正常量c,和n0，使得对所有n ≥ n0， 有0 ≤ cg(n) ≤ f(n) &#125;</span><br></pre></td></tr></table></figure>
<p>用来描述一个算法在最好情况下的运行时间</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>后进先出(last-in, first-out,LIFO)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 判断栈是否为空</span><br><span class="line">STACK-EMPTY(S)</span><br><span class="line">    if S.top == 0</span><br><span class="line">        return TRUE</span><br><span class="line">    else return FALSE</span><br><span class="line">// 压入元素</span><br><span class="line">PUSH(S, x)</span><br><span class="line">    S.top = S.top + 1</span><br><span class="line">    S[S.top] = x</span><br><span class="line"></span><br><span class="line">// 弹出元素</span><br><span class="line">POP(S)</span><br><span class="line">    if STACK-EMPTY(S)</span><br><span class="line">        error &quot;underflow&quot;</span><br><span class="line">    else S.top = S.top - 1</span><br><span class="line">        return S[S.top + 1]</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出(first-in, first-out,FIFO)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//入列</span><br><span class="line">ENQUEUE(Q, x)</span><br><span class="line">    if QUEUE-FULL(Q)</span><br><span class="line">        return</span><br><span class="line">    Q[Q.tail] = x</span><br><span class="line">    if Q.tail == Q.length</span><br><span class="line">        Q.tail = 1</span><br><span class="line">    else</span><br><span class="line">        Q.tail = Q.tail + 1</span><br><span class="line"></span><br><span class="line">//出列</span><br><span class="line">DEQUEUE(Q)</span><br><span class="line">    if QUEUE-EMPTY(Q)</span><br><span class="line">        return</span><br><span class="line">    x = Q[Q.head]</span><br><span class="line">    if Q.head = Q.length</span><br><span class="line">        Q.head = 1</span><br><span class="line">    else</span><br><span class="line">        Q.head = Q.head + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QUEUE-EMPTY(Q)</span><br><span class="line">    if Q.head == Q.tail</span><br><span class="line">        return true</span><br><span class="line">    else</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">QUEUE-FULL(Q)</span><br><span class="line">    if Q.head == Q.tail + 1 || (Q.head == 1 &amp;&amp; Q.tail == Q.length)</span><br><span class="line">        return true</span><br><span class="line">    else</span><br><span class="line">        return false</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>各个对象按照线性顺序进行排列的一种数据结构。数组的线性顺序由数组下标决定，而与之不同的是，链表的顺序<br>是由各个对象里的指针决定的。</p>
<ul>
<li>单向链表：每个对象包含一个关键字 key 和一个指针 next</li>
<li>双向链表：每个对象包含一个关键字 key 和两个指针 prev 和 next ， next 指向下一个对象， prev 指向上一个对象，<br>同时表头 prev 为 null ，表尾 next 为 null</li>
<li>双向循环链表：在双向链表的基础上，使表头的 prev 指向表尾元素，表尾的 next 指向表头元素</li>
<li>有哨兵的双向循环链表：在双向链表的基础上，设置一个哨兵对象 L.nil ，使该对象介于表头和表尾之间，即 L.nil.next<br>指向表头， L.nil.prev 指向表尾，同时使表尾的 next 和表头的 prev 都指向 L.nil</li>
</ul>
<p>以双向链表为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 搜索</span><br><span class="line">LIST-SEARCH(L,k)</span><br><span class="line">    x = L.head</span><br><span class="line">    while x ≠ NIL and x.key ≠ k</span><br><span class="line">        x = x.next</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">LIST-INSERT(L, x)</span><br><span class="line">    x.next = L.head</span><br><span class="line">    if L.head ≠ NIL</span><br><span class="line">        L.head.prev = x</span><br><span class="line">    L.head = x</span><br><span class="line">    x.prev = NIL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">LIST-DELETE(L, x)</span><br><span class="line">    if x.prev ≠ NIL</span><br><span class="line">        x.prev.next = x.next</span><br><span class="line">    else</span><br><span class="line">        L.head = x.next</span><br><span class="line"></span><br><span class="line">    if x.next ≠ NIL</span><br><span class="line">        x.next.prev = x.prev</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>由结点组成的数据结构，结点包含的链接可以为 null ，或指向其他结点。在二叉树中，除了根节点无父结点外<br>，其他的每个结点只能有一个父结点，同时每个结点都只有左右两个链接，分别指向自己的左子节点和右子节点。</p>
<ul>
<li>完全二叉树：如果一棵具有 n 个结点的深度为 k 的二叉树，它的每一个结点都与深度为k的满二叉树中编号为<br>1~n 的结点一一对应，这棵二叉树称为完全二叉树。</li>
<li>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。</li>
</ul>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>在二叉树定义的基础上，规定任何结点 x ，其左子树中的关键字最大不超过 x.key ，其右子树中的关键字最小不低于 x.key 。</p>
<ul>
<li>中序遍历(inorder tree walk): 输出的子树根的关键字位于左子树的关键字值和右子树的关键字值之间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">    if x ≠ null</span><br><span class="line">        INORDER-TREE-WALK(x.left)</span><br><span class="line">        print x.key</span><br><span class="line">        INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure>
<ul>
<li>先序遍历(preorder tree walk): 输出的子树根的关键字在其左右子树的关键字值之前。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PREORDER-TREE-WALK(x)</span><br><span class="line">    if x ≠ null</span><br><span class="line">        print x.key</span><br><span class="line">        PREORDER-TREE-WALK(x.left)</span><br><span class="line">        PREORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure>
<ul>
<li>后序遍历(postorder tree walk): 输出的子树根的关键字在其左右子树的关键字值之后。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POSTORDER-TREE-WALK(x)</span><br><span class="line">    if x ≠ null</span><br><span class="line">        POSTORDER-TREE-WALK(x.left)</span><br><span class="line">        POSTORDER-TREE-WALK(x.right)</span><br><span class="line">        print x.key</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>递归查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x,k)</span><br><span class="line">    if x == NIL or k == x.key</span><br><span class="line">        return x</span><br><span class="line">    if k &lt; x.key</span><br><span class="line">        return TREE-SEARCH(x.left, k)</span><br><span class="line">    else</span><br><span class="line">        return TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure>
<p>迭代查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ITERATIVE-TREE-SEARCH(x, k)</span><br><span class="line">    while x ≠ NIL and k ≠ x.key</span><br><span class="line">        if k &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        else</span><br><span class="line">            x = x.right</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<p>最小关键字元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MINIMUM(x)</span><br><span class="line">    while x.left ≠ NIL</span><br><span class="line">        x = x.left</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<p>最大关键字元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MAXIMUM(x)</span><br><span class="line">    while x.right ≠ NIL</span><br><span class="line">        x = x.right</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<p>后继</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x)</span><br><span class="line">    if x.right ≠ NIL</span><br><span class="line">        return TREE-MINIMUM(x.right)</span><br><span class="line">    y = x.p</span><br><span class="line">    while y ≠ NIL and x == y.right</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure>
<p>前驱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PRESUCCESSOR(x)</span><br><span class="line">    if x.left ≠ NIL</span><br><span class="line">        return TREE-MAXIMUM(x.left)</span><br><span class="line">    y = x.p</span><br><span class="line">    while y ≠ NIL and x = y.left</span><br><span class="line">        x = y</span><br><span class="line">        y = y.p</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure>
<p><strong>在一棵高度为 h 的二叉搜索树上，动态集合上的操作 SEARCH 、 MINIMUM 、 MAXIMUM 、 SUCCESSOR 和 PREDECESSOR 可以在O(h) 时间内完成。</strong></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T, z)</span><br><span class="line">    y = NIL</span><br><span class="line">    x = T.root</span><br><span class="line">    while x ≠ NIL</span><br><span class="line">        y = x</span><br><span class="line">        if z.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        else</span><br><span class="line">            x = x.right</span><br><span class="line">    z.p = y</span><br><span class="line">    if y == NIL</span><br><span class="line">        T.root = z</span><br><span class="line">    elseif z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    else</span><br><span class="line">        y.right = z</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>从一棵二叉搜索树 T 中删除结点 z 的整个策略分为三种基本情况：</p>
<ul>
<li>如果 z 没有子节点， 那么只是简单的将它删除，并修改它的父结点，用NIL作为孩子来替换 z。</li>
<li>如果 z 只有一个子节点，那么将这个孩子提升到树中 z 的位置上，并修改它的父结点，用原来 z 的孩子作为孩子来替换 z 本来的地位。</li>
<li>如果 z 有两个子节点，那么找到 z 的后继 y (一定在 z 的右子树中)，并让 y 占据树中 z 的位置。 z 的原来右子树部分成为 y 的新<br>的右子树，并且 z 的左子树成为 y 的新的左子树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 二叉搜索树内移动子树</span><br><span class="line">TRANSPLANT(T, m, n)</span><br><span class="line">    if m.p == NIL</span><br><span class="line">        T.root = n</span><br><span class="line">    elseif m == m.p.left</span><br><span class="line">        m.p.left = n</span><br><span class="line">    else</span><br><span class="line">        m.p.right = n</span><br><span class="line">    if n ≠ NIL</span><br><span class="line">        n.p = m.p</span><br><span class="line"></span><br><span class="line">TREE-DELETE(T, z)</span><br><span class="line">    if z.left == NIL</span><br><span class="line">        TRANSPLANT(T, z, z.right)</span><br><span class="line">    elseif z.right == NIL</span><br><span class="line">        TRANSPLANT(T, z, z.left)</span><br><span class="line">    else y = TREE-MINIMUM(z.right)</span><br><span class="line">        if y.p ≠ z</span><br><span class="line">            TRANSPLANT(T, y, y.right)</span><br><span class="line">            y.right = z.right</span><br><span class="line">            y.right.p = y</span><br><span class="line">        TRANSPLANT(T, z, y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.p = y</span><br></pre></td></tr></table></figure>
<p><strong>在一棵高度为 h 的二叉搜索树上，动态集合上的操作 INSERT 和 DELETE 的运行时间均为O(H)。</strong></p>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆有序：当一棵二叉树的每个结点都大于等于它的两个子节点时，它被称为堆有序。</span><br><span class="line">二叉堆：二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）</span><br></pre></td></tr></table></figure>
<p>性质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 根节点是堆有序的二叉树的最大结点</span><br><span class="line">2. 一棵大小为 N 的完全二叉树的高度为小于 lgN的最大整数</span><br><span class="line">3. 在一个二叉堆中，位置 k 的结点的父结点的位置为小于等于 k / 2 的最大整数，而它两个子节点的位置分别为 k 和 k + 1</span><br></pre></td></tr></table></figure>
<p>由下至上的堆有序化(上浮)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SWIM(A, k)</span><br><span class="line">    while k &gt; 1 and A[k] &gt; A[k/2]</span><br><span class="line">            exchange A[k] and A[k / 2]</span><br><span class="line">            k = k / 2</span><br></pre></td></tr></table></figure>
<p>由上至下的堆有序化(下沉)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SINK(A, k)</span><br><span class="line">    while 2 * k &lt;= N</span><br><span class="line">        j = 2 * k</span><br><span class="line">        if j &lt; N and A[j] &lt; A[j + 1]</span><br><span class="line">            j++</span><br><span class="line">        if A[j] &lt; A[k]</span><br><span class="line">            break</span><br><span class="line">        exchange A[j] and A[k]</span><br><span class="line">        k = j</span><br></pre></td></tr></table></figure>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>一种用来维护由一组元素构成的集合 S 的数据结构， 其中每一个元素都有一个相关的值，称为关键字 key<br>。一个最大优先队列支持以下操作：</p>
<ul>
<li>INSERT(S, x) : 把元素 x 插入集合 S 中</li>
<li>MAXIMUM(S) : 返回 S 中具有最大键值的元素</li>
<li>EXTRACT-MAX(S) : 去掉并返回 S 中的具有最大键值的元素</li>
<li>INCREASE-KEY(S, x, k) : 将元素 x 的关键字值增加到 k ，这里假设 k 的值不小于 x 的原关键字</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>假设要求的数组是正序，两两进行比较，如果前一个数比后一个数小，位置不变。<br>如果前一个数比后一个数大，位置互换，再跟后一个数进行比较，直到最后。第一轮比较产出一个<br>最大数，同时将第二轮比较的范围缩小1位，以此类推，每一轮参与比较的数据组都会产出一个“最大数”，如同冒泡一般。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BUBBLESORT(A)&#123;</span><br><span class="line">   for i = 1 to length[A]&#123;</span><br><span class="line">       for j = length[A] downto i+1&#123;</span><br><span class="line">           if A[j] &lt; A[j-1]&#123;</span><br><span class="line">                exchange A[j] and A[j-1]</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>O(n^2)</p>
<p>可以通过添加一个 flag 来对冒泡算法进行优化，此时算法时间复杂度最佳为O(n)，最坏依旧为O(N^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BUBBLESORT(A)&#123;</span><br><span class="line">    for i = 1 to A.length&#123;</span><br><span class="line">        flag = false</span><br><span class="line">        for j = A.length downto i + 1&#123;</span><br><span class="line">            if A[j] &lt; A[j - 1]&#123;</span><br><span class="line">                exchange A[j] and A[j - 1]</span><br><span class="line">                flag = true</span><br><span class="line">            &#125;</span><br><span class="line">            if flag == false&#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。<br>扑克的排序是这个算法的形象比喻：桌面上一叠未排序的扑克牌，左手拿的牌代表已排序的扑克，右手拿的表示待排序的<br>扑克牌，刚开始时左手牌为空（相当于已排序），抽一张牌给左手（依旧相当于已排序），从抽第二张牌开始，右手的牌<br>要插入左手的牌就需要与左手已经排好序的牌进行比较并插入到正确的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)&#123;</span><br><span class="line">    for i = 2 to A.length &#123;</span><br><span class="line">        j = i - 1</span><br><span class="line">        key = A[i]</span><br><span class="line">        while j &gt; 0 and key &lt; A[j]&#123;</span><br><span class="line">            A[j + 1] = A[j]</span><br><span class="line">            j = j- 1</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + 1] = key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>对于随机排序的长度为 N 且主键不重复的数组，平均情况下插入排序需要 ~N^2/4 次比较以及
~N^2/4 次交换。最坏情况下需要 ~N^2/2 次比较和 ~N^2/2次交换，最好情况下需要 N - 1 次比较和 0 次交换</code></p>
<h3 id="算法复杂度-1"><a href="#算法复杂度-1" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>最好：O(n)<br>最坏：O(n^2)</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MERGE-SORT(A,p,r)</span><br><span class="line">    IF p &lt; r</span><br><span class="line">        THEN q = [(p + r) / 2]  //问题分解</span><br><span class="line">        MERGE-SORT(A,p,q)       //继续递归直至子问题足够小</span><br><span class="line">        MERGE-SORT(A,q+1,r)     //继续递归直至子问题足够小</span><br><span class="line">        MERGE(A,p,q,r)          //合并解</span><br><span class="line"></span><br><span class="line">MERGE(A, p, q, r)</span><br><span class="line">    n1 = q - p + 1</span><br><span class="line">    n2 = r - q</span><br><span class="line">    let L[l..n1 + 1] and R[1..n2 + 1] be new arrays</span><br><span class="line">    for i = 1 to n1</span><br><span class="line">        L[i] = A[p + i - 1]</span><br><span class="line">    for j = 1 to n2</span><br><span class="line">        R[j] = A[q + j]</span><br><span class="line"></span><br><span class="line">    L[n1 + 1] = ∞</span><br><span class="line">    R[n2 + 1] = ∞</span><br><span class="line">    i = 1</span><br><span class="line">    j = 1</span><br><span class="line">    for k = p to r</span><br><span class="line">        if L[i] ≤ R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + 1</span><br><span class="line">        else</span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + 1</span><br></pre></td></tr></table></figure>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><p>分解问题的时间复杂度为O(logn),合并解的时间复杂度为O(n),整个算法的时间复杂度为O(nlogn)</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>首先找到数组中最小的元素，再将它和数组的第一个元素交换位置。接着在剩余的元素中找到最小的元素，将它与数组的第二<br>个元素进行交换。如此反复，直到将整个数组排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECTION-SORT(A)</span><br><span class="line">    for i = 1 to A.length</span><br><span class="line">        min = i</span><br><span class="line">        for j = i + 1 to A.length</span><br><span class="line">            if A[j] &lt; A[min]</span><br><span class="line">                min = j</span><br><span class="line">        exchange A[i] and A[min]</span><br></pre></td></tr></table></figure>
<p><code>对于长度为 N 的数组，选择排序需要大约 N^2 / 2次比较和N次交换</code></p>
<h3 id="算法复杂度-2"><a href="#算法复杂度-2" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>O(n^2)</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><a href="http://www.cnblogs.com/jingmoxukong/p/4303279.html" target="_blank" rel="noopener">排序四 希尔排序</a><br>基于插入排序的一种排序算法，其基本思想是使数组中任意间隔为 h 的元素都是有序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SHELL-SORT(A)</span><br><span class="line">    h = 1</span><br><span class="line">    N = A.length</span><br><span class="line">    while h &lt; N / 3</span><br><span class="line">        h = 3 * h + 1</span><br><span class="line">    while h &gt;= 1</span><br><span class="line">        for i = h to N</span><br><span class="line">            for j = i; j &gt;= h &amp;&amp; A[j] &lt;= A[j - h]; j -= h</span><br><span class="line">                exchange A[j] and A[j - h]</span><br><span class="line">            h = h / 3</span><br></pre></td></tr></table></figure>
<p>希尔排序的时间复杂度受步长的影响</p>
<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul>
<li><a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="noopener">分治算法</a></li>
<li><a href="http://www.cnblogs.com/Creator/archive/2011/06/18/2084267.html" target="_blank" rel="noopener">算法系列总结：分而治之——分治算法</a></li>
<li><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/mergeSort.htm" target="_blank" rel="noopener">Merge Sort</a></li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>归并排序、快速排序</p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2></div><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">nyakokishi</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>